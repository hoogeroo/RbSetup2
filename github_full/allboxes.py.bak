# -*- coding: utf-8 -*-
"""
Created on Tue Aug 16 15:00:25 2016

@author: mhoo027
"""


from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
import astropy.io.fits as fits
import numpy as np
from qmsbox import *
from dacprops import *
import camera_test
import DAQ
import time
import matplotlib.pyplot as plt
import EagleDAC_main as eagle

#import socket
#TCP_IP = '130.216.51.179'
#TCP_PORT = 8833
#BUFFER_SIZE = 50

MAX_INT=0xfff

class allboxes(QWidget):
    def __init__(self,ndacs,naoms,ntimes):
      super(allboxes, self).__init__()
      da.GetDevices()
      #self.setWidgetResizable(True)
      #self.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
      self.ntimes=ntimes
      self.nDACs=ndacs
      self.nAOMs=naoms
      self.setFixedHeight(700)
      self.setFixedWidth(900)
      self.nrows=self.nDACs+2*self.nAOMs
      self.layout = QGridLayout(self)
      self.layout.setSpacing(1)
      self.DAClabels=[]
      self.AOMlabels=[]
      self.Spinboxes=[]
      #self.DIOboxes=[]
      self.Timeboxes=[]
      self.DCSpinboxes=[]
      #self.DCDIOboxes=[]
      #self.testbox=QMSbox(345,544)
      self.testbox=QLabel('DC Values')
      #self.testbox.setFont(QFont('Arial',7))
      self.layout.addWidget(self.testbox,0,0)
      #self.testbox.valueChanged.connect(self.testbox.valuechange)
      #self.testbox.
      self.Timelabel=QLabel('Time (ms)')
      #self.Timelabel.setFont(QFont('Arial',7))
      self.layout.addWidget(self.Timelabel,0,1)
      for i in range(self.ntimes):
          self.Timeboxes.append(Timebox())
          #self.Timeboxes[-1].setFont(QFont('Arial',7))
          self.layout.addWidget(self.Timeboxes[i],0,i+2)
      for i in range(self.nDACs):
          self.DCSpinboxes.append(DC_DAC_Box(i))
          #self.DCSpinboxes[-1].setFont(QFont('Arial', 7))
          self.layout.addWidget(self.DCSpinboxes[i],i+1,0)
      for i in range(2*self.nAOMs):
          j=i//2
          if ((i%2) == 0) :
              self.DCSpinboxes.append(DC_AOM_Freq_Box(j))
          else:
              self.DCSpinboxes.append(DC_AOM_Ampl_Box(j))
          #self.DCSpinboxes[-1].setFont(QFont('Arial', 7))
          self.layout.addWidget(self.DCSpinboxes[i+self.nDACs],i+self.nDACs+1,0)
          #self.DCSpinboxes[i].valueChanged.connect(self.DCSpinboxes[i].valuechange)
      for i in range(self.nDACs):
          self.DAClabels.append(QLabel(dac_names[i]))
          #self.DAClabels[-1].setFont(QFont('Arial', 7))
          self.layout.addWidget(self.DAClabels[i],i+1,1)
      for i in range(2*self.nAOMs):
          aomno=i//2
          if (i%2==0):
              mystr=" Freq "
          else:
              mystr=" Ampl "
          self.AOMlabels.append(QLabel(aom_names[aomno]+mystr))
          #self.AOMlabels[-1].setFont(QFont('Arial',8))
          #self..setAlignment(Qt.AlignCenter)
          self.layout.addWidget(self.AOMlabels[i],i+self.nDACs+1,1)
      for j in range(self.ntimes):
          self.Spinboxes.append([])
          #self.DIOboxes.append([])
          for i in range(self.nDACs):
              #print(i,j)
              self.Spinboxes[j].append(DAC_Box(i,j))
              self.layout.addWidget(self.Spinboxes[j][i],i+1,j+2)
              self.Spinboxes[j][i].setRange(-10,10)
          for i in range(2*self.nAOMs):
              self.Spinboxes[j].append(QMSbox(i+self.nDACs,j))
              self.layout.addWidget(self.Spinboxes[j][i+self.nDACs],i+self.nDACs+1,j+2)
              if (i%2==0):
                  self.Spinboxes[j][-1].setValue(80.0)
              else:
                  self.Spinboxes[j][-1].setValue(1.0)
              #self.Spinboxes[j][i].valueChanged.connect(self.valuechange(i,j))
      self.cambox=QSpinBox()
      self.layout.addWidget(self.cambox,44,4)
      self.camlabel=QLabel('Camera shots')
      self.layout.addWidget(self.camlabel,44,3)
      self.GoButton=QPushButton('Go')
      self.CycleButton=QPushButton('Cycle')
      self.layout.addWidget(self.GoButton,44,1)
      self.layout.addWidget(self.CycleButton,45,1)
      self.sbNCycles=QSpinBox()
      self.layout.addWidget(self.sbNCycles)
      self.cbPictype=QComboBox()
      self.cbPictype.addItem("No picture")
      self.cbPictype.addItem("One shot")
      self.cbPictype.addItem("Fluorescence")
      self.cbPictype.addItem("Shadow image")
      self.layout.addWidget(self.cbPictype,44,5)
      self.setLayout(self.layout)
      self.setWindowTitle("Simple Experiment Controller")
      self.GoButton.clicked.connect(self.GoAction)
      self.CycleButton.clicked.connect(self.CycleAction)
      self.camera=camera_test.camera()
      self.EDRE=DAQ.EDRE_Interface()
      self.cycling=False
      self.cbMOTLoad=QCheckBox()
      self.cbMOTLoad.stateChanged.connect(self.TimerChange)
      self.MOTLoadLabel=QLabel('Load MOT')
      self.layout.addWidget(self.cbMOTLoad,44,0)
      self.layout.addWidget(self.MOTLoadLabel,45,0)
      self.MOTTimer=QTimer(self)
      self.MOTTimer.timeout.connect(self.MOTTimerAction)
      
    def MOTTimerAction(self):
        if self.nAOMs>0:
          self.DCSpinboxes[9+2].setValue(0.0)
          self.DCSpinboxes[9+6].setValue(0.4)
          time.sleep(0.02)
          self.DCSpinboxes[9+2].setValue(1.0)
          self.DCSpinboxes[9+6].setValue(0.0)
          #print("cycle")
        else:
          self.DCSpinboxes[18].setValue(0.0)
          self.DCSpinboxes[20].setValue(5.0)
          time.sleep(0.02)
          self.DCSpinboxes[18].setValue(5.0)
          self.DCSpinboxes[20].setValue(0.0)

    def TimerChange(self):
        if self.cbMOTLoad.checkState():
            self.MOTTimer.start(100)
        else:
            self.MOTTimer.stop()

    def CycleAction(self):
        print('CycleAction')
        if self.cycling:
            self.cycling=False
            self.CycleButton.setText('No Cycle')
            self.EDRE.stop()
        else:
            self.loadData()
            self.CycleButton.setText('Cycling')
            self.cycling=True
            if self.sbNCycles.value()==0:
                while self.cycling:
                    self.doGo()
                    print(self.totaltime)
                    time.sleep(0.001*self.totaltime)
            else:
                for i in range(self.sbNCycles.value()):
                    self.doGo()
                    time.sleep(0.001*self.totaltime)


    def DelCol(self,where):
        print(where)
        where=where-1
        ntimes=self.ntimes
        import sip
        for i in range(ntimes-where-1):
            print(i+where)
            self.Timeboxes[i+where].setValue(self.Timeboxes[i+where+1].value())
        self.layout.removeWidget(self.Timeboxes[-1])
        sip.delete(self.Timeboxes[-1])
        for col in range(ntimes-where-1):
            for row in range(self.nrows):
                self.Spinboxes[col+where][row].setValue(self.Spinboxes[col+where+1][row].value())
        for row in range(self.nrows):
            self.layout.removeWidget(self.Spinboxes[-1][row])
            sip.delete(self.Spinboxes[-1][row])
        self.ntimes=ntimes-1
        self.Spinboxes.pop()

    def DupCol(self,where):
        print(where)
        ntimes=self.ntimes
        #where=self.where
        #self.ntimes+=1
        #self.Timeboxes.insert(where,QDoubleSpinBox())
        #self.Timeboxes[where+1].setValue(self.Timeboxes[where].value())
        self.AddCol()
        steps=ntimes-where
        for i in range(steps):
            self.Timeboxes[ntimes-i].setValue(self.Timeboxes[ntimes-i-1].value())
            for j in range(self.nrows):
                self.Spinboxes[ntimes-i][j].setValue(self.Spinboxes[ntimes-i-1][j].value())

    def AddCol(self):
        self.ntimes+=1
        self.parent().coldup_actions.append(QAction('Column '+str(self.ntimes),self))
        self.parent().column_dup.addAction(self.parent().coldup_actions[-1])
        self.Timeboxes.append(Timebox())
        #self.Timeboxes[-1].setFont(QFont('Arial', 7))
        self.layout.addWidget(self.Timeboxes[-1],0,self.ntimes+1)
        self.Spinboxes.append([])
        for i in range(self.nDACs):
            self.Spinboxes[-1].append(DAC_Box(i,self.ntimes))
            self.layout.addWidget(self.Spinboxes[-1][-1],i+1,self.ntimes+1)
        for i in range(2*self.nAOMs):
            self.Spinboxes[-1].append(QMSbox(i+self.nDACs,self.ntimes))
            if (i%2==0):
                self.Spinboxes[-1][-1].setValue(80.0)
            else:
                self.Spinboxes[-1][-1].setValue(1.0)
            self.layout.addWidget(self.Spinboxes[-1][-1],i+1+self.nDACs,self.ntimes+1)

    def GoAction(self):
        self.loadData()
        self.MOTTimer.stop()
        #self.DCSpinboxes[20].setValue(5.0)
        #self.DCSpinboxes[18].setValue(5.0)
        self.doGo()
        for i in range(self.nDACs):
          self.DCSpinboxes[i].updateDAC()
        if self.cbMOTLoad.isChecked():
          self.MOTTimer.start(100)


    def loadData(self):
        self.totaltime=0.0
        self.timestep=0.05
        for col in range(self.ntimes):
            self.totaltime+=self.Timeboxes[col].value()
        nsteps=int(self.totaltime/self.timestep) # assuming timesteps of 0.1 ms
        #if nsteps < 65536:
        #  size = 65560
        #else:
        #  size = nsteps
        data=np.zeros((nsteps,self.nDACs),dtype=int)
        timestepstilnow=0
        thetime=0.0
        msg='LOAD,'
        msg2='LOAD,'
        for col in range(self.ntimes):
            timesteps=int(self.Timeboxes[col].value()/self.timestep)
            for t in range(timesteps):
                i = t + timestepstilnow
                for row in range(self.nDACs):
                    temp=self.Spinboxes[col][row].value()
                    if ((temp>=0.0) and (temp<=5.0)):
                        data[i,row]=int(temp*MAX_INT/5.0)
                    elif (temp==-20.0):
                        tmp2=self.Spinboxes[col][row].LOffset+self.Spinboxes[col][row].LAmp/(1.0+(t*self.timestep/self.Spinboxes[col][row].LTc)**2)
                        data[i,row]=int(tmp2*MAX_INT/5.0)
                    elif (temp==-30.0):
                        tmp2=self.Spinboxes[col][row].RStart+t*(self.Spinboxes[col][row].REnd-self.Spinboxes[col][row].RStart)/timesteps
                        data[i,row]=int(tmp2*MAX_INT/5.0)
            timestepstilnow+=timesteps
            self.data=data
            if self.nAOMs>0:
              for AOM in range(4): # Prepare message for 1st AOM
                t1=2*AOM+self.nDACs
                if col==0: # We need a special case for the first column, we need to compare to DC value rather than previous column
                    temp=self.Spinboxes[col][t1].value()
                    t2=AOM+10
                    if temp!=self.DCSpinboxes[t1].value():
                        msg=msg+str(t2)+','+'FREQ,'+str(AOM)+','+str(temp)+','
                    temp=self.Spinboxes[col][t1+1].value()
                    if temp!=self.DCSpinboxes[t1+1].value():
                        msg=msg+str(t2)+','+'AMPL,'+str(AOM)+','+str(temp)+','
                else:
                    temp=self.Spinboxes[col][t1].value()
                    if temp!=self.Spinboxes[col-1][t1].value():
                        msg=msg+str((int(thetime*1000)+AOM))+','+'FREQ,'+str(AOM)+','+str(temp)+','
                    temp=self.Spinboxes[col][t1+1].value()
                    if temp!=self.Spinboxes[col-1][t1+1].value():
                        msg=msg+str((int(thetime*1000)+AOM))+','+'AMPL,'+str(AOM)+','+str(temp)+','
            if self.nAOMs>4:
              for AOM in range(4): # Same for second AOM
                t1=2*AOM+self.nDACs+8
                if col==0:
                    temp=self.Spinboxes[col][t1].value()
                    print(temp,t1,self.DCSpinboxes[t1].value())
                    if temp!=self.DCSpinboxes[t1].value():
                        msg2=msg2+'10,'+'FREQ,'+str(AOM)+','+str(temp)+','
                    temp=self.Spinboxes[col][t1+1].value()
                    if temp!=self.DCSpinboxes[t1+1].value():
                        msg2=msg2+'10,'+'AMPL,'+str(AOM)+','+str(temp)+','
                else:
                    temp=self.Spinboxes[col][t1].value()
                    if temp!=self.Spinboxes[col-1][t1].value():
                        msg2=msg2+str((int(thetime*1000)))+','+'FREQ,'+str(AOM)+','+str(temp)+','
                    temp=self.Spinboxes[col][t1+1].value()
                    if temp!=self.Spinboxes[col-1][t1+1].value():
                        msg2=msg2+str((int(thetime*1000)))+','+'AMPL,'+str(AOM)+','+str(temp)+','
            thetime=thetime+self.Timeboxes[col].value()
        msg=msg+"F"
        msg2=msg2+"F"
        if (len(msg)>6):
            print(msg)
            s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((TCP_IP, TCP_PORT))
            s.send(msg.encode())
            print(s.recv(5))
            s.close()
        if (len(msg2)>6):
            print(msg2)
            #s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            #s.connect((TCP_IP2, TCP_PORT))
            #s.send(msg2.encode())
            #s.recv(5)
            #s.close()
        #self.nsamples=size
        self.nsamples=timestepstilnow
        #print(data.shape,nsamples)
        #print(nsamples)

    def doGo(self):
        nshots=self.cbPictype.currentIndex()
        if (nshots>0):
            self.camera.shoot(nshots)
        s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((TCP_IP, TCP_PORT))
        msg='EXPT'
        s.send(msg.encode())
        print(s.recv(5))
        s.close()
        time.sleep(0.01)
        #s.connect((TCP_IP2, TCP_PORT))
        #s.send(msg.encode())
        #s.recv(5)
        #s.close()
        nsamples=self.data.shape[0]
        data = self.data.flatten('C').astype(np.ushort)
        datalen=data.shape[0]
        if (datalen<=0x10001) :        
            firstval=data[0]+0x1000
            data2=np.ones(0x10001,dtype=np.ushort)*firstval
            data2[0:datalen]=data[:]
            data=data2
        data[datalen-1]+=0x8000
        datalen=data.shape[0]
        print("Data shape is ",data.shape)
        print("First 10 points ",data[0:10])
        freq=20000
        #print(data[24:34])
        #self.EDRE.stop(0)
        #self.EDRE.run(0,self.nsamples,data)
        #time.sleep(self.nsamples*50e-6+0.001)
        #self.EDRE.stop(0)
        result=da.DACOutputProcess(0,freq,datalen,data)
        print("Result is ",result,nsamples)
        if (nshots>0):
            self.mydata=self.camera.read()
            plt.imshow(self.mydata)
            plt.show()
        f=open('test.txt','w')
        for i in range(self.data.shape[0]):
          for j in range(self.data.shape[1]):
            f.write("%d \n" % self.data[i,j])
        f.close()
        #plt.plot(self.data[:,0])
        #plt.show()


    def valuechange(self,i,j):
       print(self.Spinboxes[self.i][self.j].value())
      #self.l1.setText("current value:"+str(self.sp.value()))

if __name__=='__main__':
  npts=100000
  da.GetDevices()
  t=np.arange(npts)/npts
  data=np.zeros((npts,8))
  for j in range(8):
    data[:,j]=np.sin(10*t+j)**2*4096
  data2=data.flatten('C').astype(np.ushort)
  print(data2[0:10])
  print(data2.shape)
  data2[-1]+=0x8000
  result=da.DACOutputProcess(0,20000,8*npts,data2)
  print(result)
  
  
